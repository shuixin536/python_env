# -*- coding: utf-8 -*-

from befh.restful_api_socket import RESTfulApiSocket
from befh.exchange import ExchangeGateway
from befh.market_data import L2Depth, Trade
from befh.util import Logger
from befh.instrument import Instrument
from befh.sql_client_template import SqlClientTemplate
from functools import partial
from datetime import datetime
from multiprocessing import Process
import time
import threading
from market_data import MarketDataBase
import calendar
from uuid import uuid4
import os
import json

#import requests.packages.urllib3.util.ssl_
#requests.packages.urllib3.util.ssl_.DEFAULT_CIPHERS = 'ALL'

'''
api doc:https://developer.big.one/
python demo ref: https://github.com/sammchardy/python-bigone
'''


def _get_uuid():
    return str(uuid4())

class ExchGwApiBigOne(RESTfulApiSocket):
    """
    Exchange gateway RESTfulApi
    """
    UUID = _get_uuid()
    def __init__(self):
        RESTfulApiSocket.__init__(self)

    @classmethod
    def _handle_creds(cls, path_to_creds=None):
        # Helper function to handle BigOne API keys.
        if not path_to_creds:
            path_to_creds = os.path.join(os.path.abspath(os.path.dirname(__file__)), "exch_bigone.json")

        with open(path_to_creds, "r") as read:
            return json.load(read)
        
    @classmethod
    def get_timestamp_offset(cls):
        return 1000
        
    @classmethod
    def get_order_book_timestamp_field_name(cls):
        return 'date'
        
    @classmethod
    def get_trades_timestamp_field_name(cls):
        return 'created_at'

    @classmethod
    def get_bids_field_name(cls):
        return 'bids'
        
    @classmethod
    def get_asks_field_name(cls):
        return 'asks'

    @classmethod
    def get_trade_side_field_name(cls):
        return 'trade_side'

    @classmethod
    def get_trade_id_field_name(cls):
        return 'trade_id'

    @classmethod
    def get_trade_price_field_name(cls):
        return 'price'

    @classmethod
    def get_trade_volume_field_name(cls):
        return 'amount'
        
    @classmethod
    def get_order_book_link(cls, instmt):
        # 获取速度太快，可能导致没有新的订单出来，一直获取的是同一条
        return "https://api.big.one/markets/%s/book" % instmt.get_instmt_code()

    @classmethod
    def get_trades_link(cls, instmt):
        return "https://api.big.one/markets/%s/trades" % instmt.get_instmt_code()
                
    @classmethod
    def parse_l2_depth(cls, instmt, raw):
        """
        Parse raw data to L2 depth
        :param instmt: Instrument
        :param raw: Raw data in JSON
        """
        raw = raw["data"]
        l2_depth = L2Depth()
        keys = list(raw.keys())
        if cls.get_bids_field_name() in keys and \
           cls.get_asks_field_name() in keys:
            
            # No Date time information, has update id only
            l2_depth.date_time = calendar.timegm(datetime.utcnow().timetuple()) #datetime.now().strftime("%Y%m%d %H:%M:%S.%f")

            # Bids----我想要买，出的买价
            # 默认是从高到低排序，所以需要反转-----
            # 从低到高--->b[0]取出买价里面的更高价
            # b[0] > b[1] > b[2] > b[3] > b[4]
            bids = raw[cls.get_bids_field_name()]
            bids = sorted(bids, key=lambda x: float(x["price"]), reverse=True)
            for i in range(0, min(len(bids), 5)):
                l2_depth.bids[i].price = float(bids[i]["price"]) if type(bids[i]["price"]) != float else bids[i]["price"]
                l2_depth.bids[i].volume = float(bids[i]["amount"]) if type(bids[i]["amount"]) != float else bids[i]["amount"]
                
            # Asks----卖价--------筛选出低的价格
            # a[0] < a[1] < a[2] < a[3] < a[4]
            # a[0] > b[0]
            asks = raw[cls.get_asks_field_name()]
            asks = sorted(asks, key=lambda x: x["price"])
            for i in range(0, min(len(asks), 5)):
                l2_depth.asks[i].price = float(asks[i]["price"]) if type(asks[i]["price"]) != float else asks[i]["price"]
                l2_depth.asks[i].volume = float(asks[i]["amount"]) if type(asks[i]["amount"]) != float else asks[i]["amount"]
        else:
            raise Exception('Does not contain order book keys in instmt %s-%s.\nOriginal:\n%s' % \
                (instmt.get_exchange_name(), instmt.get_instmt_name(), \
                 raw))
        
        return l2_depth

    @classmethod
    def parse_trade(cls, instmt, raw):
        """
        :param instmt: Instrument
        :param raw: Raw data in JSON
        :return:
        """
        trade = Trade()
        keys = list(raw.keys())
        
        if cls.get_trades_timestamp_field_name() in keys and \
           cls.get_trade_side_field_name() in keys and \
           cls.get_trade_id_field_name() in keys and \
           cls.get_trade_price_field_name() in keys and \
           cls.get_trade_volume_field_name() in keys:
        
            # Date time
            timestamp = raw[cls.get_trades_timestamp_field_name()]
            timestamp = timestamp.replace('T', ' ').replace('Z', '').replace('-' , '')
            timestamp = list(timestamp.split("."))[0]
            date_time = datetime.strptime(timestamp, "%Y%m%d %H:%M:%S")
            trade.date_time = calendar.timegm(date_time.timetuple()) # timestamp
            
            # Trade side
            trade.trade_side = trade.trade_side = 1 if raw[cls.get_trade_side_field_name()] == 'BID' else 2
                
            # Trade id
            trade.trade_id = str(raw[cls.get_trade_id_field_name()])
            
            # Trade price
            trade.trade_price = float(str(raw[cls.get_trade_price_field_name()]))
            
            # Trade volume
            trade.trade_volume = float(str(raw[cls.get_trade_volume_field_name()]))
        else:
            raise Exception('Does not contain trade keys in instmt %s-%s.\nOriginal:\n%s' % \
                (instmt.get_exchange_name(), instmt.get_instmt_name(), \
                 raw))        

        return trade

    @classmethod
    def get_order_book(cls, instmt):
        """
        Get order book
        :param instmt: Instrument
        :return: Object L2Depth
        """
        # If verify cert, got <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:749)>

        crds = cls._handle_creds()
        API_KEY = crds['k']
        extra_header = {'Authorization': 'Bearer {}'.format(API_KEY),
                        'Big-Device-Id': cls.UUID}
        res = cls.request(cls.get_order_book_link(instmt), verify_cert=False, extra_header = extra_header)
        if len(res) > 0:
            return cls.parse_l2_depth(instmt=instmt,
                                       raw=res)
        else:
            return None

    @classmethod
    def get_trades(cls, instmt):
        """
        Get trades
        :param instmt: Instrument
        :param trade_id: Trade id
        :return: List of trades
        """
        link = cls.get_trades_link(instmt)
        #print(link)
        # If verify cert, got <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:749)>
        res = cls.request(link, verify_cert=False)
        trades = []
        if 'data' in res.keys():
            res = res['data']
            if len(res) > 0:
                for t in res:
                    trade = cls.parse_trade(instmt=instmt,
                                            raw=t)
                    trades.append(trade)

        return trades


class ExchGwBigOne(ExchangeGateway):
    """
    Exchange gateway
    """
    def __init__(self, db_clients):
        """
        Constructor
        :param db_client: Database client
        """
        ExchangeGateway.__init__(self, ExchGwApiBigOne(), db_clients)

    @classmethod
    def get_exchange_name(cls):
        """
        Get exchange name
        :return: Exchange name string
        """
        return 'BigOne'

    def get_order_book_worker(self, instmt):
        """
        Get order book worker
        :param instmt: Instrument
        """
        while instmt.keep_running:
            try:
                l2_depth = self.api_socket.get_order_book(instmt)
                # 获取速度太快，可能导致没有新的订单出来，一直获取的是同一条
                if l2_depth is not None and l2_depth.is_diff(instmt.get_l2_depth()):
                    instmt.set_prev_l2_depth(instmt.get_l2_depth())
                    instmt.set_l2_depth(l2_depth)
                    instmt.incr_order_book_id()
                    self.insert_order_book(instmt)
            except Exception as e:
                Logger.error(self.__class__.__name__, "Error in order book: %s" % e)
            time.sleep(1)

    def get_trades_worker(self, instmt):
        """
        Get order book worker thread
        :param instmt: Instrument name
        """
        while instmt.keep_running:
            try:
                ret = self.api_socket.get_trades(instmt)
                if ret is None or len(ret) == 0:
                    time.sleep(1)
                    continue
            except Exception as e:
                Logger.error(self.__class__.__name__, "Error in trades: %s" % e)
                time.sleep(1)
                continue
                
            for trade in ret:
                assert isinstance(trade.trade_id, str), "trade.trade_id(%s) = %s" % (type(trade.trade_id), trade.trade_id)
                assert isinstance(instmt.get_exch_trade_id(), str), \
                       "instmt.get_exch_trade_id()(%s) = %s" % (type(instmt.get_exch_trade_id()), instmt.get_exch_trade_id())
                if trade.trade_id != instmt.get_exch_trade_id():
                    instmt.set_exch_trade_id(trade.trade_id)
                    instmt.incr_trade_id()
                    self.insert_trade(instmt, trade)
            
            # After the first time of getting the trade, indicate the instrument
            # is recovered
            if not instmt.get_recovered():
                instmt.set_recovered(True)

            time.sleep(1)

    def start(self, instmt):
        """
        Start the exchange gateway
        :param instmt: Instrument
        :return List of threads
        """
        instmt.set_l2_depth(L2Depth(5))
        instmt.set_prev_l2_depth(L2Depth(5))
        instmt.set_instmt_snapshot_table_name(self.get_instmt_snapshot_table_name(instmt.get_exchange_name(),
                                                                                  instmt.get_instmt_name()))
        self.init_instmt_snapshot_table(instmt)
        instmt.set_recovered(False)

        #t1 = threading.Thread(target=partial(self.get_order_book_worker, instmt))
        t2 = threading.Thread(target=partial(self.get_trades_worker, instmt))
        #t1.start()
        t2.start()


        return [t2]
        
        
if __name__ == '__main__':
    Logger.init_log()
    exchange_name = 'BigOne'
    instmt_name = 'LTCBTC'
    instmt_code = 'LTCBTC'
    instmt = Instrument(exchange_name, instmt_name, instmt_code)    
    db_client = SqlClientTemplate()
    exch = ExchGwBigOne([db_client])
    instmt.set_l2_depth(L2Depth(5))
    instmt.set_prev_l2_depth(L2Depth(5))
    instmt.set_recovered(False)    
    exch.get_order_book_worker(instmt)
    exch.get_trades_worker(instmt)