#!/bin/python
# -*- coding: utf-8 -*-

import argparse
import sys
import signal
import os
import thread, time

from befh.exchange import ExchangeGateway
from befh.exch_bitmex import ExchGwBitmex
from befh.exch_btcc import ExchGwBtccSpot, ExchGwBtccFuture
from befh.exch_bitfinex import ExchGwBitfinex
from befh.exch_okcoin import ExchGwOkCoin
from befh.exch_okex import ExchGwOkEx
from befh.exch_kraken import ExchGwKraken
from befh.exch_gdax import ExchGwGdax
from befh.exch_bitstamp import ExchGwBitstamp
from befh.exch_gatecoin import ExchGwGatecoin
from befh.exch_quoine import ExchGwQuoine
from befh.exch_poloniex import ExchGwPoloniex
from befh.exch_bittrex import ExchGwBittrex
from befh.exch_yunbi import ExchGwYunbi
from befh.exch_liqui import ExchGwLiqui
from befh.exch_binance import ExchGwBinance
from befh.exch_cryptopia import ExchGwCryptopia
from befh.exch_huobi import ExchGwHuobi
from befh.exch_bigone import ExchGwBigOne
from befh.exch_bithumb import ExchGwBithumb
from befh.exch_coinone import ExchGwCoinone
from befh.exch_coinnest import ExchGwCoinnest
from befh.exch_korbit import ExchGwKorbit
from befh.exch_luno import ExchGwLuno

from befh.kdbplus_client import KdbPlusClient
from befh.mysql_client import MysqlClient
from befh.sqlite_client import SqliteClient
from befh.file_client import FileClient
from befh.zmq_client import ZmqClient
from befh.subscription_manager import SubscriptionManager
from befh.util import Logger

from befh.instrument import Instrument
from befh.market_data import L2Depth
from decimal import *
import calendar
from datetime import datetime

import requests

def main():
    parser = argparse.ArgumentParser(description='Bitcoin exchange market data feed handler.')
    parser.add_argument('-instmts', action='store', help='Instrument subscription file.', default='subscriptions.ini')
    parser.add_argument('-exchtime', action='store_true', help='Use exchange timestamp.')
    parser.add_argument('-kdb', action='store_true', help='Use Kdb+ as database.')
    parser.add_argument('-csv', action='store_true', help='Use csv file as database.')
    parser.add_argument('-sqlite', action='store_true', help='Use SQLite database.')
    parser.add_argument('-mysql', action='store_true', help='Use MySQL.')
    parser.add_argument('-zmq', action='store_true', help='Use zmq publisher.')
    parser.add_argument('-mysqldest', action='store', dest='mysqldest',
                        help='MySQL destination. Formatted as <name:pwd@host:port>',
                        default='')
    parser.add_argument('-mysqlschema', action='store', dest='mysqlschema',
                        help='MySQL schema.',
                        default='')
    parser.add_argument('-kdbdest', action='store', dest='kdbdest',
                        help='Kdb+ destination. Formatted as <host:port>',
                        default='')
    parser.add_argument('-zmqdest', action='store', dest='zmqdest',
                        help='Zmq destination. For example \"tcp://127.0.0.1:3306\"',
                        default='')
    parser.add_argument('-sqlitepath', action='store', dest='sqlitepath',
                        help='SQLite database path',
                        default='')
    parser.add_argument('-csvpath', action='store', dest='csvpath',
                        help='Csv file path',
                        default='')
    parser.add_argument('-output', action='store', dest='output',
                        help='Verbose output file path')
    args = parser.parse_args()

    Logger.init_log(args.output)

    db_clients = []
    is_database_defined = False
    if args.sqlite:
        db_client = SqliteClient()
        db_client.connect(path=args.sqlitepath)
        db_clients.append(db_client)
        is_database_defined = True
    if args.mysql:
        db_client = MysqlClient()
        mysqldest = args.mysqldest
        logon_credential = mysqldest.split('@')[0]
        connection = mysqldest.split('@')[1]
        db_client.connect(host=connection.split(':')[0],
                          port=int(connection.split(':')[1]),
                          user=logon_credential.split(':')[0],
                          pwd=logon_credential.split(':')[1],
                          schema=args.mysqlschema)
        db_clients.append(db_client)
        is_database_defined = True
    if args.csv:
        if args.csvpath != '':
            db_client = FileClient(dir=args.csvpath)
        else:
            db_client = FileClient()
        db_clients.append(db_client)
        is_database_defined = True
    if args.kdb:
        db_client = KdbPlusClient()
        db_client.connect(host=args.kdbdest.split(':')[0], port=int(args.kdbdest.split(':')[1]))
        db_clients.append(db_client)
        is_database_defined = True
    if args.zmq:
        db_client = ZmqClient()
        db_client.connect(addr=args.zmqdest)
        db_clients.append(db_client)
        is_database_defined = True

    if not is_database_defined:
        print('Error: Please define which database is used.')
        parser.print_help()
        sys.exit(1)

    # Subscription instruments
    if args.instmts is None or len(args.instmts) == 0:
        print('Error: Please define the instrument subscription list. You can refer to subscriptions.ini.')
        parser.print_help()
        sys.exit(1)
        
    # Use exchange timestamp rather than local timestamp
    if args.exchtime:
        ExchangeGateway.is_local_timestamp = False
    
    # Initialize subscriptions
    subscription_instmts = SubscriptionManager(args.instmts).get_subscriptions()
    if len(subscription_instmts) == 0:
        print('Error: No instrument is found in the subscription file. ' +
              'Please check the file path and the content of the subscription file.')
        parser.print_help()
        sys.exit(1)        
    
    # Initialize snapshot destination
    ExchangeGateway.init_snapshot_table(db_clients)

    Logger.info('[main]', 'Subscription file = %s' % args.instmts)
    log_str = 'Exchange/Instrument/InstrumentCode:\n'
    for instmt in subscription_instmts:
        log_str += '%s/%s/%s\n' % (instmt.exchange_name, instmt.instmt_name, instmt.instmt_code)
    Logger.info('[main]', log_str)
    
    exch_gws = []
    exch_gws.append(ExchGwBtccSpot(db_clients))
    exch_gws.append(ExchGwBtccFuture(db_clients))
    exch_gws.append(ExchGwBitmex(db_clients))
    exch_gws.append(ExchGwBitfinex(db_clients))
    exch_gws.append(ExchGwOkCoin(db_clients))
    exch_gws.append(ExchGwOkEx(db_clients))
    exch_gws.append(ExchGwKraken(db_clients))
    exch_gws.append(ExchGwGdax(db_clients))
    exch_gws.append(ExchGwBitstamp(db_clients))
    exch_gws.append(ExchGwGatecoin(db_clients))
    exch_gws.append(ExchGwQuoine(db_clients))
    exch_gws.append(ExchGwPoloniex(db_clients))
    exch_gws.append(ExchGwBittrex(db_clients))
    exch_gws.append(ExchGwYunbi(db_clients))
    exch_gws.append(ExchGwLiqui(db_clients))
    exch_gws.append(ExchGwBinance(db_clients))
    exch_gws.append(ExchGwCryptopia(db_clients))
    exch_gws.append(ExchGwHuobi(db_clients))
    exch_gws.append(ExchGwBigOne(db_clients))
    exch_gws.append(ExchGwBithumb(db_clients))
    exch_gws.append(ExchGwCoinone(db_clients))
    exch_gws.append(ExchGwCoinnest(db_clients))
    exch_gws.append(ExchGwKorbit(db_clients))
    exch_gws.append(ExchGwLuno(db_clients))

    threads = []
    for exch in exch_gws:
        for instmt in subscription_instmts:
            if instmt.get_exchange_name() == exch.get_exchange_name():
                Logger.info("[main]", "Starting instrument %s-%s..." % \
                    (instmt.get_exchange_name(), instmt.get_instmt_name()))
                exch.willStart(instmt)
                threads += exch.start(instmt)

    return exch_gws, db_clients, subscription_instmts


def input_thread(L):
    raw_input()
    L.append(None)

instmt_ask_min_pre = None
instmt_bid_max_pre = None
def calculateCoinPair(instmt_list):

    #dbrows = [d_Binance, d_OkEx, d_Huobi]

    if instmt_list is None or len(instmt_list) <= 1:
        return

    x1_min = sys.maxint
    x2_max = 0
    instmt_ask_min = instmt_list[0]
    instmt_bid_max = instmt_list[0]
    for instmt in instmt_list:
        l2_depth = instmt.get_l2_depth()
        x1_min = min(x1_min, l2_depth.bids[0].price)
        x2_max = max(x2_max, l2_depth.asks[0].price)

        l2_depth_ask_min = instmt_ask_min.get_l2_depth()
        l2_depth_bid_max = instmt_bid_max.get_l2_depth()
        if l2_depth_ask_min.asks[0].price > l2_depth.asks[0].price:
            instmt_ask_min = instmt
        if l2_depth_bid_max.bids[0].price < l2_depth.bids[0].price:
            instmt_bid_max = instmt

    l2_depth_ask_min = instmt_ask_min.get_l2_depth()
    l2_depth_bid_max = instmt_bid_max.get_l2_depth()

    show_price_graph = True
    if show_price_graph:
        print ("\r\n\r\n\r\n\r\n")
        price_range = x2_max - x1_min
        price_range_char_len = 100

        for instmt in instmt_list:
            l2_depth = instmt.get_l2_depth()
            x1 = price_range_char_len * (l2_depth.bids[0].price - x1_min) / price_range
            length = price_range_char_len * (l2_depth.asks[0].price - l2_depth.bids[0].price) / price_range

            tip = ""
            if l2_depth_bid_max.bids[0].price > l2_depth_ask_min.asks[0].price:
                if l2_depth == l2_depth_ask_min:
                    tip += "@BUY"
                elif l2_depth == l2_depth_bid_max:
                    tip += "@SELL"
            tip += "@" + instmt.get_exchange_name()

            print ("%s%18.10f|%s|%0.10f%s" % (
                " " * int(x1), l2_depth.bids[0].price, "-" * int(length), l2_depth.asks[0].price, tip))


    if l2_depth_bid_max.bids[0].price > l2_depth_ask_min.asks[0].price and l2_depth_ask_min.asks[0].price > 0:
        # TODO: 如果数据库中的数据更新没有那么及时，这里线程一直获取到的都是老数据，对冲提醒也就过时了
        profit = (l2_depth_bid_max.bids[0].price - l2_depth_ask_min.asks[0].price) / l2_depth_ask_min.asks[0].price
        if profit >= 0.001:
            ask_exchange = instmt_ask_min.get_exchange_name()
            ask_exchange = ask_exchange.encode('utf-8')
            ask_a1_lowest = l2_depth_ask_min.asks[0].price
            ask_a1_volume = l2_depth_ask_min.asks[0].volume

            bid_exchange = instmt_bid_max.get_exchange_name()
            bid_exchange = bid_exchange.encode('utf-8')
            bid_b1_highest = l2_depth_bid_max.bids[0].price
            bid_b1_volume = l2_depth_bid_max.bids[0].volume

            coinpair = instmt_ask_min.get_instmt_name()
            coinpair = list(coinpair.split("_"))[1].encode('utf-8')

            tips = "对冲提醒%s\n卖方交易所:%s\n卖出Price:%f\n买方交易所:%s\n买进Price:%f\n交易数量:%f\n交易利润:%f\n" % (coinpair,
                bid_exchange, bid_b1_highest, ask_exchange, ask_a1_lowest, min(ask_a1_volume, bid_b1_volume), profit)
            print (tips)

            instmt_ask_min_pre = instmt_ask_min
            instmt_bid_max_pre = instmt_bid_max




def do_print():
    L = []
    thread.start_new_thread(input_thread, (L,))
    l2_depth_ask_lowest_pre = None
    l2_depth_bid_highest_pre = None
    while 1:
        time.sleep(3)
        if L:
            print ("time to quit")
            break

        db_instmts = []
        #print "Hi Mom!"
        if len(db_clients) > 0:
            db_client = db_clients[0]
            #print ("\r\n\r\n\r\n\r\n")
            # L2Depth depth =
            # 'exchange', 'instmt', 'trade_px', 'trade_volume', 'b1', 'b2', 'b3', 'b4', 'b5', 'a1', 'a2', 'a3', 'a4', 'a5'
            # 0           1         2           3               4     5     6     7     8     9     10    11    11    12

            # 'bq1', 'bq2', 'bq3', 'bq4', 'bq5', 'aq1', 'aq2', 'aq3', 'aq4', 'aq5', 'order_date_time', 'trades_date_time', 'update_type'
            # 13     14     15     16     17     18     19     20     21     22     23                 24                  25

            # 找出最低的卖价(出价), # 找出最高的买价
            # 可能第一条记录及时最低的卖价，也有最高的买价，无效的一条记录
            # TODO: 查询条件考虑增加时间因素，距离当前时刻6s内的数据才是有效的，防止有些平台的数据是过时了，导致一直认为是交易对
            coinpair = "NEOBTC"
            timestamp = calendar.timegm(datetime.utcnow().timetuple())
            sql_condition = 'instmt like \"%%_%s\" and order_date_time > %d and order_date_time < %d' % (coinpair, timestamp-2, timestamp + 5)
            dbrows = db_client.select(table=ExchangeGateway.get_snapshot_table_name(), columns=['exchange', 'instmt', 'b1', 'a1', 'bq1', 'aq1'],
                                         condition=sql_condition, orderby='', limit=0,
                                         isFetchAll=True)
            print_db_column = True
            if print_db_column:
                print ("------------------------------------------")
                print ("%18s %18s %18s %18s" % ("exchange", "instmt", "b1", "a1"))
                for row in dbrows:
                    print ("%18s %18s %18.10f %18.10f" % (row[0], row[1], row[2], row[3]))


            instmt_list = []
            for dbrow in dbrows:
                params = {}
                instmt = Instrument(dbrow[0], dbrow[1], "", **params)
                l2_depth = L2Depth(5)
                # Bids
                l2_depth.bids[0].price = dbrow[2]
                l2_depth.bids[0].volume = dbrow[4]

                # Asks
                l2_depth.asks[0].price = dbrow[3]
                l2_depth.asks[0].volume = dbrow[5]

                instmt.set_l2_depth(l2_depth)
                instmt_list.append(instmt)

            calculateCoinPair(instmt_list)

    for exch in exch_gws:
        for instmt in subscription_instmts:
            if instmt.get_exchange_name() == exch.get_exchange_name():
                Logger.info("[main]", "Stoping instrument %s-%s..." % \
                    (instmt.get_exchange_name(), instmt.get_instmt_name()))
                exch.stop(instmt)

def do_print_thread():
    thread.start_new_thread(do_print, ())

exch_gws = []
db_clients = []
subscription_instmts = []
if __name__ == '__main__':
    do_print_thread()
    exch_gws, db_clients, subscription_instmts = main()
